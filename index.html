<!DOCTYPE html>
<html>
	<meta charset="utf-8" />
	<style>
		svg {
			width: 800px;
			height: 800px;
		}
	</style>

	<body>
		<div id="controls">
			<label for="severityFilter">Filter by severity:</label>
			<select id="severityFilter">
				<option value="all">All</option>
				<option value="2">Severity 2</option>
				<option value="4">Severity 4</option>
			</select>
			<label for="startTimeSlider"> Filter by start time:</label>

			<input id="startTimeSlider" type="range" min="0" max="23" value="0" />
			<span id="timeDisplay">12:00 AM</span>
			<button id="showAllTimesBtn">Show All Times</button>
		</div>
		<svg></svg>
	</body>

	<script src="http://d3js.org/d3.v6.min.js"></script>

	<script>
		// ------------------------ SET UP canvas --------------------------
		var margin = { top: 20, right: 20, bottom: 20, left: 20 },
			width = +400 - margin.left - margin.right,
			height = +400 - margin.top - margin.bottom;

		var svg = d3
			.select('svg')
			.attr('width', width + margin.left + margin.right)
			.attr('height', height + margin.top + margin.bottom);

		// ------------------------ SET UP MAP LAYER --------------------------
		//projection coverts geojson coords to svg coords
		var projection = d3
			.geoAlbersUsa()
			.scale(4000)
			.translate([width / 20 - 400, height / 20 - 400]);

		//geopath coverts geojson geometry to svg path
		//projection here is func we use to convert geometry points into svg points
		var path = d3.geoPath().projection(projection);

		var statesLayer = svg.append('g').attr('class', 'states');
		var crashesLayer = svg.append('g').attr('class', 'crashes');

		// ------------------------ INITIAL STATE OF GLOBAL VARIABLES ------------------------

		let allPoints = [];
		let mapFeatures = [];
		let currentSeverity = 'all';
		let currentTime = 0;
		let filterByTime = false;

		// creating a tooltip
		var tooltip = d3
			.select('body')
			.append('div')
			.style('position', 'absolute')
			.style('visibility', 'hidden')
			.style('background-color', 'white')
			.style('border', 'solid')
			.style('border-width', '1px')
			.style('padding', '10px');

		// Create the zoom handler
		svg.selectAll('path, circle').style('vector-effect', 'non-scaling-stroke');

		// Tell browser to prepare for heavy lifting
		statesLayer.style('will-change', 'transform');
		crashesLayer.style('will-change', 'transform');

		var zoom = d3
			.zoom()
			.scaleExtent([1, 8]) // Limit zoom: Min 1x, Max 8x
			.on('zoom', function (event) {
				// Get the transform (x, y, k) from the event
				var transform = event.transform;

				// Apply it to both layers
				statesLayer.attr('stroke-width', 1).attr('transform', transform);
				crashesLayer.attr('stroke-width', 1).attr('transform', transform);
			});

		// ------------------------ LOAD IN AND PRE-PROCESS DATA ------------------------
		d3.json('FLmap.json')
			.then(function (us) {
				mapFeatures = us.features;

				// draw the map first so that users can see something is being loaded in while they wait on the points
				statesLayer
					.selectAll('path') //inside of the svg layer we made we will select all paths (on first pass this is none)
					.data(mapFeatures) //then we bind the path objects to our features
					.enter()
					.append('path') //styling for the path
					.attr('d', path)
					.attr('stroke', '#000000')
					.attr('fill', '#ffffff')
					.attr('opacity', 0.7);

				d3.json('FLdata.json')
					.then(function (points) {
						allPoints = points.features;

						// pre-calculate projections for all crash points
						allPoints.forEach((point) => {
							// creating a new property for each point so that we can save their projection and render them much faster later
							point.projected = projection(point.geometry.coordinates);

							// TODO: check if really ok to just assign whatever here
							// Ensure ID for D3 key function
							if (!point.properties.id) {
								point.properties.id = Math.random();
							}
						});

						allPoints = allPoints.filter((point) => point.projected !== null);

						// render the points for the first time
						updateAndFilterPoints();
					})
					.catch((error) => {
						console.log('Error loading in FLdata.json:', error);
					});
			})
			.catch((error) => {
				console.log('Error loading in FLmap.json:', error);
			});

		//  ------------------------ SET UP  helpers  --------------------------

		// function that draws the circles based on a given dataset
		function renderPoints(data) {
			crashesLayer
				//grab all circles from the svg and bind them to the features (passed in data)
				.selectAll('circle')
				.data(data)
				.data(
					data.filter((d) => d.projected),
					(d) => d.properties.id
				)
				//draw a circle at the specified coordinates
				.join('circle')
				.attr('cx', (d) => d.projected[0])
				.attr('cy', (d) => d.projected[1])
				.attr('r', 1)
				.attr('stroke', '#666666')
				.attr('fill', '#888888')
				.attr('opacity', 0.7)
				.on('mouseover', function (event, data) {
					d3.select(this)
						.attr('fill', 'red')
						.attr('stroke', 'red')
						.attr('r', 4);

					tooltip.html(data.properties.severity);

					tooltip.style('visibility', 'visible');
					tooltip
						.style('top', event.offsetY - 15 + 'px')
						.style('left', event.offsetX + 15 + 'px');
				})
				.on('mouseout', function (event, data) {
					d3.select(this)
						.attr('stroke', '#666666')
						.attr('fill', '#888888')
						.attr('r', 1);

					tooltip.style('visibility', 'hidden');
				});
		}

		function updateAndFilterPoints() {
			let filteredPoints = allPoints;

			//filter by severity
			if (currentSeverity !== 'all') {
				filteredPoints = filteredPoints.filter(
					(point) => String(point.properties.severity) === currentSeverity
				);
			}

			//filter by starttime if filtering enabled
			if (filterByTime) {
				filteredPoints = filteredPoints.filter((point) => {
					const timeString = point.properties.starttime[0];
					const hour = parseInt(timeString.split(' ')[1].split(':')[0]);
					return hour === currentTime;
				});
			}

			renderPoints(filteredPoints);
		}

		// connect the dropdown menu to the visualization
		function setupFilter() {
			d3.select('#severityFilter').on('change', function () {
				currentSeverity = this.value;
				console.log('current severity:' + currentSeverity);
				updateAndFilterPoints();
			});
		}

		function setupSliders() {
			d3.select('#startTimeSlider').on('input', function () {
				currentTime = parseInt(this.value);
				filterByTime = true;

				let displayHour = currentTime;
				let period = 'AM';

				if (currentTime === 0) {
					displayHour = 12;
				} else if (currentTime === 12) {
					displayHour = 12;
					period = 'PM';
				} else if (currentTime > 12) {
					displayHour = currentTime - 12;
					period = 'PM';
				}

				const displayText = displayHour + ':00 ' + period;
				d3.select('#timeDisplay').text(displayText);
				updateAndFilterPoints();
			});
		}

		function setupButtons() {
			d3.select('#showAllTimesBtn').on('click', function () {
				filterByTime = false;
				updateAndFilterPoints();
			});
		}

		setupFilter();
		setupSliders();
		setupButtons();
		svg.call(zoom);
	</script>
</html>
