<!DOCTYPE html>
<html>
	<meta charset="utf-8" />
	<style>
		svg {
			width: 65vw;
			height: 65vw;
		}

		/* GPU acceleration for smoother transforms */
		.states,
		.crashes {
			will-change: transform;
		}

		/* Optimize rendering performance */
		.states path {
			stroke-width: 1px;
			vector-effect: non-scaling-stroke;
		}

		.crashes circle {
			stroke-width: 1px;
			vector-effect: non-scaling-stroke;
		}
	</style>

	<body>
		<div id="controls">
			<label for="severityFilter">Filter by severity:</label>
			<select id="severityFilter">
				<option value="all">All</option>
				<option value="2">Severity 2</option>
				<option value="4">Severity 4</option>
			</select>
			<label for="startTimeSlider"> Filter by start time:</label>

			<input id="startTimeSlider" type="range" min="0" max="23" value="0" />
			<span id="timeDisplay">12:00 AM</span>
			<button id="showAllTimesBtn">Show All Times</button>
		</div>
		<svg></svg>
	</body>

	<script src="https://d3js.org/d3.v6.min.js"></script>

	<script>
		// ------------------------ SET UP canvas --------------------------
		var margin = { top: 20, right: 20, bottom: 20, left: 20 },
			width = window.innerWidth - margin.left - margin.right,
			height = window.innerHeight - margin.top - margin.bottom;

		var svg = d3
			.select('svg')
			.attr('width', width + margin.left + margin.right)
			.attr('height', height + margin.top + margin.bottom);

		// ------------------------ SET UP MAP LAYER --------------------------
		//projection coverts geojson coords to svg coords
		var projection = d3
			.geoAlbersUsa()
			.scale(4000)
			.translate([width / 20 - width / 3, height / 20 - height / 2]);

		//geopath coverts geojson geometry to svg path
		//projection here is func we use to convert geometry points into svg points
		var path = d3.geoPath().projection(projection);

		var statesLayer = svg.append('g').attr('class', 'states');
		var crashesLayer = svg.append('g').attr('class', 'crashes');

		// ------------------------ INITIAL STATE OF GLOBAL VARIABLES ------------------------

		let allPoints = [];
		let mapFeatures = [];
		let currentSeverity = 'all';
		let currentTime = 0;
		let filterByTime = false;
		let isZooming = false;

		// creating a tooltip
		var tooltip = d3
			.select('body')
			.append('div')
			.style('position', 'absolute')
			.style('visibility', 'hidden')
			.style('background-color', 'white')
			.style('border', 'solid')
			.style('border-width', '1px')
			.style('padding', '10px');

		// Create the zoom handler and optimize it with throttling
		var zoom = d3
			.zoom()
			.scaleExtent([1, 8]) // zoom ranges from minimum of 1x to maximum of 8x
			.filter(function (event) {
				// Allow wheel events to be passive when possible
				return !event.ctrlKey && !event.button;
			})
			.on(
				'start',
				function () {
					isZooming = true;
					tooltip.style('visibility', 'hidden');
				},
				16
			) // 60 fps throttling
			.on(
				'zoom',
				throttle(function (event) {
					currentTransform = event.transform;
					statesLayer.attr('transform', currentTransform);
					crashesLayer.attr('transform', currentTransform);
				}, 16)
			)
			.on('end', function () {
				isZooming = false;
				tooltip.style('visibility', 'visible');
			});

		// ------------------------ LOAD IN AND PRE-PROCESS DATA ------------------------
		d3.json('FLmap.json')
			.then(function (us) {
				mapFeatures = us.features;

				// draw the map first so that users can see something is being loaded in while they wait on the points
				statesLayer
					.selectAll('path') //inside of the svg layer we made we will select all paths (on first pass this is none)
					.data(mapFeatures) //then we bind the path objects to our features
					.enter()
					.append('path') //styling for the path
					.attr('d', path)
					.attr('stroke', '#000000')
					.attr('fill', '#ffffff')
					.attr('opacity', 0.7);

				d3.json('FLdata.json')
					.then(function (points) {
						allPoints = points.features;

						// pre-calculate projections for all crash points
						allPoints.forEach((point, index) => {
							// creating a new property for each point so that we can save their projection and render them much faster later
							point.projected = projection(point.geometry.coordinates);

							if (
								point.properties.id === null ||
								point.properties.id === undefined
							) {
								point.properties.id = index;
							}

							return point;
						});

						allPoints = allPoints.filter((point) => point.projected !== null);

						// Initial render with requestAnimationFrame for better performance
						requestAnimationFrame(() => {
							updateAndFilterPoints();
						});
					})
					.catch((error) => {
						console.log('Error loading in FLdata.json:', error);
					});
			})
			.catch((error) => {
				console.log('Error loading in FLmap.json:', error);
			});

		// ------------------------ OPTIMIZING PERFORMANCE ------------------------
		// Throttle function to limit function calls
		function throttle(func, delay) {
			let timeoutId;
			let lastExecTime = 0;
			return function (...args) {
				const currentTime = Date.now();

				if (currentTime - lastExecTime > delay) {
					func.apply(this, args);
					lastExecTime = currentTime;
				} else {
					clearTimeout(timeoutId);
					timeoutId = setTimeout(() => {
						func.apply(this, args);
						lastExecTime = Date.now();
					}, delay - (currentTime - lastExecTime));
				}
			};
		}

		//  ------------------------ SET UP  helpers  --------------------------

		// function that draws the circles based on a given dataset
		function renderPoints(data) {
			const renderData = data;

			const circles = crashesLayer
				.selectAll('circle')
				.data(renderData, (d) => d.properties.id);

			// Delete circles for data points that no longer exist
			circles.exit().remove();

			// Add new circles for new data points
			const newCircles = circles
				.enter()
				.append('circle')
				.attr('r', 1)
				.attr('stroke', '#666666')
				.attr('fill', '#888888')
				.attr('opacity', 0.7);

			// Update existing and new circles
			circles
				.merge(newCircles)
				.attr('cx', (d) => d.projected[0])
				.attr('cy', (d) => d.projected[1])
				.on('mouseover', function (event, data) {
					// Disable hover during zoom for performance
					if (isZooming) return;

					d3.select(this)
						.attr('fill', 'red')
						.attr('stroke', 'red')
						.attr('r', 4);

					tooltip.html(`Severity: ${data.properties.severity}`);
					tooltip
						.style('visibility', 'visible')
						.style('top', event.pageY - 15 + 'px')
						.style('left', event.pageX + 15 + 'px');
				})
				.on('mouseout', function (event, data) {
					d3.select(this)
						.attr('stroke', '#666666')
						.attr('fill', '#888888')
						.attr('r', 1);

					tooltip.style('visibility', 'hidden');
				});
		}

		function updateAndFilterPoints() {
			let filteredPoints = allPoints;

			//filter by severity
			if (currentSeverity !== 'all') {
				filteredPoints = filteredPoints.filter(
					(point) => String(point.properties.severity) === currentSeverity
				);
			}

			//filter by starttime if filtering enabled
			if (filterByTime) {
				filteredPoints = filteredPoints.filter((point) => {
					const timeString = point.properties.starttime;
					const hour = parseInt(timeString.split(' ')[1].split(':')[0]);
					return hour === currentTime;
				});
			}

			// Use requestAnimationFrame for smooth rendering
			requestAnimationFrame(() => {
				renderPoints(filteredPoints);
			});
		}

		// connect the dropdown menu to the visualization
		function setupFilter() {
			d3.select('#severityFilter').on('change', function () {
				currentSeverity = this.value;
				console.log('current severity:' + currentSeverity);
				updateAndFilterPoints();
			});
		}

		function setupSliders() {
			d3.select('#startTimeSlider').on('input', function () {
				currentTime = parseInt(this.value);
				filterByTime = true;

				let displayHour = currentTime;
				let period = 'AM';

				if (currentTime === 0) {
					displayHour = 12;
				} else if (currentTime === 12) {
					displayHour = 12;
					period = 'PM';
				} else if (currentTime > 12) {
					displayHour = currentTime - 12;
					period = 'PM';
				}

				const displayText = displayHour + ':00 ' + period;
				d3.select('#timeDisplay').text(displayText);
				updateAndFilterPoints();
			});
		}

		function setupButtons() {
			d3.select('#showAllTimesBtn').on('click', function () {
				filterByTime = false;
				updateAndFilterPoints();
			});
		}

		//  ------------------------ SETUP EXECUTION --------------------------
		setupFilter();
		setupSliders();
		setupButtons();
		svg.call(zoom);
	</script>
</html>
